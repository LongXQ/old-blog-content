<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="丑霸一枚" />



  <meta name="keywords" content="Hexo,next" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="丑霸一枚">
<meta property="og:type" content="website">
<meta property="og:title" content="坚持锻炼">
<meta property="og:url" content="http://iovcc.com/index.html">
<meta property="og:site_name" content="坚持锻炼">
<meta property="og:description" content="丑霸一枚">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="坚持锻炼">
<meta name="twitter:description" content="丑霸一枚">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'post'
  };
</script>

  <title> 坚持锻炼 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  

  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?5ba8d0a18b1ab8a44c3c0e6556c5017f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">坚持锻炼</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            <i class="menu-item-icon icon-next-categories"></i> <br />
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            <i class="menu-item-icon icon-next-commonweal"></i> <br />
            公益404
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/03/12/hello-world/" itemprop="url">
                getaddrinfo函数
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-03-12T16:03:26+08:00" content="2016-03-12">
            2016-03-12
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/socket编程/" itemprop="url" rel="index">
                  <span itemprop="name">socket编程</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/03/12/hello-world/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/12/hello-world/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="getaddrinfo"><a href="#getaddrinfo" class="headerlink" title="getaddrinfo"></a>getaddrinfo</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getaddrinfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *nodename, <span class="keyword">const</span> <span class="keyword">char</span> *servname, <span class="keyword">const</span> <span class="keyword">struct</span> addrinfo *hints, <span class="keyword">struct</span> addrinfo **res)</span></span>;</span><br></pre></td></tr></table></figure>
<p>socket编程的目的就是进行主机与主机之间的通信，那么我们在连接目的主机之前，我们肯定要获取目的主机的一些信息，比如主机的IP地址，主机的端口号等等。<br>getaddrinfo函数的目的就是用来干这个的，它把获取到的信息保存到addrinfo结构体中。getaddrinfo函数应该是socket编程中第一个调用的函数，毕竟只有获取到了目的主机的信息才能通信。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> addrinfo&#123;</span><br><span class="line">	<span class="keyword">int</span> ai_flags;		<span class="comment">// AI_PASSIVE,AI_CANONNAME,...</span></span><br><span class="line">	<span class="keyword">int</span> ai_family;		<span class="comment">// AI_INET,AI_INET6,AI_UNSPEC</span></span><br><span class="line">	<span class="keyword">int</span> ai_socktype;	<span class="comment">// SOCK_STREAM,SOCK_DGRAM</span></span><br><span class="line">	<span class="keyword">int</span> ai_protocol;	<span class="comment">// 当为0的时候，系统会自动为你选取协议或者 IPPROTO_TCP,IPPROTO_UDP...</span></span><br><span class="line">	<span class="keyword">size_t</span> ai_addrlen;	<span class="comment">// ai_addr的大小</span></span><br><span class="line">	<span class="keyword">struct</span> sockaddr *ai_addr;	<span class="comment">//struct sockaddr_in 或者 struct sockaddr_in6，用来存放IP地址和端口号等信息</span></span><br><span class="line">	<span class="keyword">char</span> *ai_canonname;	<span class="comment">// 主机的canonical名字</span></span><br><span class="line">	<span class="keyword">struct</span> addrinfo *ai_next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h3><ol>
<li>nodename是目的主机的名字，可以是”www.example.com”的形式，也可以是IP地址的形式(注意是字符串表示)。</li>
<li>servname是端口号。你可以传进来一个数字形式的端口号或者是一个服务名字，如”http” “tftp”等。系统会帮你自动转换成服务对应的端口号。</li>
<li>最后一个传入参数是hints。我们注意到这是一个addrinfo结构的参数。这个参数是用来告诉getaddrinfo函数应该怎么去获取信息。我们只会用到该结构的ai_flags,ai_family,ai_socktype,ai_protocol这几个字段。</li>
<li>res就是当我们获取到了目的主机信息后把这些信息保存到的地方。<br>关于hints参数：当ai_flags==AI_PASSIVE的时候，nodename可以为NULL，表示我们用INADDR_ANY(IPv4)或IN6ADDR_ANY(IPv6)填充res的地址字段，在随后的bind函数中，会用本机的ip地址自动填充sockaddr的ip地址字段<br>当ai_protocol==0的时候，系统会自动帮你获取协议，如当ai_socktype==SOCK_STREAM类型，那么系统就会知道你要使用TCP协议，那么系统就会自动帮你选取该协议。<br>当我们不知道目的主机的IP地址是ipv4还是ipv6的时候，我们可以指定ai_family=AI_UNSPEC，这样getaddrinfo函数会搜索目的主机的ipv4地址和ipv6地址。<h3 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h3>假如我们要获取www.example.com主机的信息<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> addrinfo hints,*res;</span><br><span class="line"><span class="built_in">memset</span>(&amp;hints,<span class="number">0</span>,<span class="keyword">sizeof</span>(hints));</span><br><span class="line">hints.ai_family=AI_UNSPEC;</span><br><span class="line">hints.ai_socktype=SOCK_STREAM;	<span class="comment">//表示我们要获取的socket类型为SOCK_STREAM类型</span></span><br><span class="line"><span class="keyword">int</span> rv=getaddrinfo(<span class="string">"www.example.com"</span>,<span class="string">"8080"</span>,&amp;hints,&amp;res);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上面表示我们要获取主机名为www.example.com，服务为http(8080)，并且连接的socket类型要为SOCK_STREAM。</p>
<h3 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">获取本地主机的信息</span><br><span class="line"><span class="keyword">struct</span> addrinfo hints,*res;</span><br><span class="line"><span class="built_in">memset</span>(&amp;hints,<span class="number">0</span>,<span class="keyword">sizeof</span>(hints));</span><br><span class="line">hints.ai_flags=AI_PASSIVE;</span><br><span class="line">hints.ai_family=AI_UNSPEC;</span><br><span class="line">hints.ai_socktype=SOCK_STREAM;</span><br><span class="line"><span class="keyword">int</span> rev=getaddrinfo(<span class="string">"www.example.com"</span>,<span class="string">"8080"</span>,&amp;hints,*res);</span><br></pre></td></tr></table></figure>
<h2 id="sockaddr系列结构"><a href="#sockaddr系列结构" class="headerlink" title="sockaddr系列结构"></a>sockaddr系列结构</h2><p>通过上面我们知道，struct sockaddr结构是用来保存主机的ip地址和端口号信息的。但是我们知道ipv4和ipv6协议有很大的不同，其中就包括ip地址的长度都不一样，ipv4的ip地址只要4个字节表示，但是ipv6的ip地址要用16个字节表示。但是我们在上面看到，struct addrinfo中只有sockaddr这一个字段用来表示地址和端口号信息，那么系统是如何统一ipv4和ipv6的呢。<br>我们先来看一些结构<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> sockaddr&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> sa_family;</span><br><span class="line">	<span class="keyword">char</span> sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> sockaddr_in&#123;</span><br><span class="line">	<span class="keyword">short</span> <span class="keyword">int</span> sin_family;	<span class="comment">// AF_INET</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> sin_port;	<span class="comment">// 端口号</span></span><br><span class="line">	<span class="keyword">struct</span> in_addr sin_addr;	<span class="comment">//IP地址</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="number">8</span>];	<span class="comment">//填充字段，为了和sockaddr一样的大小</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> in_addr&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> s_addr;	<span class="comment">//4个字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> sockaddr_in6&#123;</span><br><span class="line">	<span class="keyword">u_int16_t</span> sin6_family;	<span class="comment">// AF_INET6</span></span><br><span class="line">	<span class="keyword">u_int16_t</span> sin6_port;	<span class="comment">// 端口号</span></span><br><span class="line">	<span class="keyword">u_int32_t</span> sin6_flowinfo; <span class="comment">// IPV6的flow information</span></span><br><span class="line">	<span class="keyword">struct</span> in6_addr sin_addr;	<span class="comment">//IPv6的地址</span></span><br><span class="line">	<span class="keyword">u_int32_t</span> sin6_scope_id;	<span class="comment">//Scope ID</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> in6_addr&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> s6_addr[<span class="number">16</span>];	<span class="comment">//IPv6地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到struct sockaddr_in是用来保存IPv4的地址信息，struct sockaddr_in6是用来保存IPv6的地址信息的。并且这两个结构的大小还不一样。<br>从以上三个结构中我们可以看到三个结构中的第一个字段(ai_family,sin_family,sin6_family)都是用来保存address family的。所以我们根据sockaddr的ai_family字段得出该sockaddr代表的是IPv4还是IPv6.<br>当我们通过getaddrinfo函数得到了目的主机的信息后，我们可以这样来得到地址信息:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> sockaddr *p=res;</span><br><span class="line"><span class="keyword">struct</span> sockaddr_in *addr_4;</span><br><span class="line"><span class="keyword">struct</span> sockaddr_in6 *addr_6;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;ai_family==AF_INET)&#123;</span><br><span class="line">	addr_4=(<span class="keyword">struct</span> sockaddr_in *)p;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;ai_family==AF_INET6&#123;</span><br><span class="line">	add_6=(<span class="keyword">struct</span> sockaddr_in6 *)p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>更一般的系统还提供了一个通用的结构，这个结构足够大以便能够容纳IPv4地址信息或IPv6地址信息。该结构体一般用在我们需要显示提供sockaddr结构的地方<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> sockaddr_storage&#123;</span><br><span class="line">	<span class="keyword">sa_family_t</span> ss_family;	<span class="comment">// AF_INET或AF_INET6</span></span><br><span class="line">	<span class="comment">//下面的三个字段都是用来填充的</span></span><br><span class="line">	<span class="keyword">char</span> __ss_pad1[_SS_PAD1SIZE];</span><br><span class="line">	<span class="keyword">char</span> __ss_align;</span><br><span class="line">	<span class="keyword">char</span> __ss_pad2[_SS_PAD2SIZE];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到struct sockaddr_storage结构体能够容纳IPv6的地址信息和IPv4的地址信息，也可以看到该结构体的第一个字段也是表示address family的字段ss_family。<br>这样我们就可以更具ss_family的值把sockaddr_storage结构转换成相应的sockaddr_in或者sockaddr_in6结构。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> sockaddr_storage addr;</span><br><span class="line"><span class="keyword">socklen_t</span> sin_size;</span><br><span class="line">accept(sockfd,(<span class="keyword">struct</span> sockaddr *)&amp;addr,&amp;sin_size);</span><br></pre></td></tr></table></figure></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/11/30/c-异常机制/" itemprop="url">
                c++异常机制
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-11-30T10:40:16+08:00" content="2015-11-30">
            2015-11-30
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/11/30/c-异常机制/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/11/30/c-异常机制/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>c++异常机制包括三个部分:异常抛出，异常捕获处理，和栈回退。<br>其中栈回退主要是用来确保在异常被抛出，捕获并处理后，所有生命期已结束的对象都会被正确地析构，他们所占用的空间会被正确地回收。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/11/10/signal/" itemprop="url">
                signal
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-11-10T11:27:01+08:00" content="2015-11-10">
            2015-11-10
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/11/10/signal/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/11/10/signal/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h4 id="信号的状态机"><a href="#信号的状态机" class="headerlink" title="信号的状态机"></a>信号的状态机</h4><p>当一个信号产生时，内核通常在进程表中以某种形式设置一个标志。当对信号采取了这种时，我们说向进程递送了一个信号。在信号产生和递送之间的时间间隔内，该信号是未决的(pending)。<br>如果该信号被阻塞了，而且对该信号的动作是系统默认或捕捉该信号，则为该进程将此信号保持为未决状态，直到该进程对该信号解除阻塞或者将对次信号的动作更改为忽略。如果对该处于未决状态的信号解除了阻塞而且对该信号的动作不是忽略，那么该信号就会被递送给进程。进程是在信号递送给它时决定对它的处理方式，所以在信号递送之前任然可以改变对该信号的处理动作，这也是前面说到的对处于未决状态的信号我们仍然可以更改该信号的动作为忽略。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/11/04/jinchengkongzhi/" itemprop="url">
                jinchengkongzhi
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-11-04T20:43:20+08:00" content="2015-11-04">
            2015-11-04
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/11/04/jinchengkongzhi/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/11/04/jinchengkongzhi/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h4 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h4><p>每一个进程除了有一进程ID之外，还属于一个进程组。<br>进程组是一个或多个进程的集合。通常，它们是同一作业中结合起来的，同一进程组中的各进程接收来自同一个终端的各种信号。每一个进程组有一个唯一的进程组ID。<br>每一个进程组有一个组长进程，进程组ID等于其进程ID。<br>进程组组长可以创建一个进程组，创建该组中的进程，然后终止。只要在某个进程组中有一个进程存在，则该进程组就存在，这与其组长进程是否终止无关。<br>从进程组创建开始到其中最后一个进程离开为止的时间区间称为进程组的生命期。<br>某个进程组中的最后一个进程可以终止，也可以转移到另一个进程组。</p>
<h4 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h4><p>会话是一个或多个进程组的集合。<br>进程调用setsid函数建立一个新会话。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> setsid(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure></p>
<p>如果调用此函数的进程不是一个进程组的组长，则此函数创建一个新会话。具体会发生3件事。</p>
<ol>
<li>该进程变成新会话的会话首进程(session leader，会话首进程是创建该会话的进程)。此时，该进程是新会话中的唯一进程。</li>
<li>该进程成为一个新进程组的组长进程。新进程组ID是该调用进程的进程ID。</li>
<li>该进程没有控制终端。如果在调用setsid之前该进程有一个控制终端，那么这种联系也被切断。<br>如果该调用进程已经是一个进程组的组长，则此函数返回出错。为了保证不处于这种情况，通常先调用fork，然后使其父进程终止，而子进程则继续。因为子进程继承了父进程的进程组ID，而其进程ID则是新分配的，两者不可能相等，这就保证了子进程不是一个进程组的组长。<h4 id="控制终端"><a href="#控制终端" class="headerlink" title="控制终端"></a>控制终端</h4></li>
<li>一个会话可以有一个控制终端。这通常是终端设备或伪终端设备。</li>
<li>建立与控制终端连接的会话首进程被成为控制进程。</li>
<li>一个会话中的几个进程组可被分为一个前台进程组以及一个或多个后台进程组。</li>
<li>如果一个会话有一个控制终端，则它有一个前台进程组，其他进程组为后台进程组。</li>
<li>无论何时键入终端的终端键(Ctrl+C)，都会将中断信号发送至前台进程组的所有进程。</li>
<li>无论何时键入终端的退出键(通常是Ctrl+)，都会将退出信号发送至前台进程组的所有进程。<br>有时不管标准输入，标准输出是否重定向，程序都要与控制终端交互作用。保证程序能与控制终端对话的方法是open文件/dev/tty。在内核中，此特殊文件是控制终端的同义语。自然地，如果程序没有控制终端，则对于此设备的open将失败。意思是如果标准输入输出被重定向到其它地方去了，那么此时就不能利用标准输入输出和终端交互了，解决办法就是用open方法打开/dev/tty文件，用返回的文件描述符可以和终端交互(前提是进程有控制终端)<h4 id="作业控制"><a href="#作业控制" class="headerlink" title="作业控制"></a>作业控制</h4>一个作业就是一组进程的集合，也就是一个进程组。<br>我们可以键入一个影响前台作业的特殊字符–挂起键(Ctrl+Z)，与终端驱动程序进行交互作用。键入此字符使终端驱动程序将信号SIGTSTP发送至前台进程组中的所有进程，后台进程组作业则不受影响。#### 孤儿进程组<br>一个其父进程已终止的进程成为孤儿进程，这种进程由init进程收养。<br>孤儿进程组的定义是一个一个进程组中每一个成员的父进程不属于该会话中。也就是一个进程组不是孤儿进程组的条件是–该组中有一个进程，其父进程在属于同一会话的另一个组中。</li>
</ol>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/11/04/pid/" itemprop="url">
                有效用户ID和保存的设置用户ID
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-11-04T17:20:52+08:00" content="2015-11-04">
            2015-11-04
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/11/04/pid/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/11/04/pid/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>一个进程都有实际用户ID，有效用户ID和保存的设置用户ID。其中实际用户ID和有效用户ID都可以通过下面的函数得到或设置。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setuid</span><span class="params">(uid_t uid)</span>    <span class="comment">//设置进程的实际用户ID和有效用户ID</span></span><br><span class="line"><span class="keyword">int</span> <span class="title">getuid</span><span class="params">(<span class="keyword">void</span>)</span>    <span class="comment">//得到进程的实际用户ID</span></span><br><span class="line"><span class="keyword">int</span> <span class="title">seteuid</span><span class="params">(uid_t uid)</span>    <span class="comment">//设置进程的有效用户ID</span></span><br><span class="line"><span class="keyword">int</span> <span class="title">geteuid</span><span class="params">(<span class="keyword">void</span>)</span>    <span class="comment">//得到进程的有效用户ID</span></span></span><br></pre></td></tr></table></figure></p>
<p>这些ID的作用其实控制进程访问权限的，比如一些资源只能给超级用户访问，那么如果具有一般用户权限的进程就没有资格访问。<br>那他们在进程的初始化过程中是怎么设置的呢？<br>当一个程序文件被执行时，进程的实际用户ID和有效用户ID都被设置成执行这个程序文件的用户ID，而不管这个程序的文件的所有者是谁。如果这个程序文件的设置用户位被设置了，那么有效用户ID被初始化为这个程序文件的所有者用户ID。而对于进程的保存的设置用户ID则是复制进程的有效用户ID。<br>在控制进程的访问控制权限是通过有进程的用户ID来判断的。<br>为什么进程要有有效用户ID和保存的设置用户ID呢？<br>进程为什么这么麻烦要设置这么多个ID呢，为什么不直接使用实际用户ID来控制访问权限呢，毕竟有效用户ID代表着实际执行这个程序的用户，理应以实际用户ID为准的。<br>之所以还要有有效的用户ID是因为，进程有可能在执行过程中，访问权限会发生变化，比如有可能当前进程只需要具有普通用户的权限就可以了，但是过会进程需要超级用户权限才能继续执行。所以才有了有效用户ID。而这样的程序文件如果要更改访问权限，必须程序文件的设置用户位被设置了才能更改。<br>最后对于保存的设置用户ID的作用是用来恢复有效用户ID到初始状态的，毕竟有效用户ID既然能改变，那就有可能恢复到改变前的ID，而恢复肯定依照某个东西来恢复才行，不能乱来，这个依照物就是进程保存的设置用户ID。<br>下面以例子说明：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// repid.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">uid_t</span> uid=getuid();</span><br><span class="line">	<span class="keyword">uid_t</span> euid=geteuid();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"uid=%d\n"</span>,uid);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"euid=%d\n"</span>,euid);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面这个程序就是打印进程的实际用户ID和有效用户ID的。假设当前系统有两个用户root和user1，root用户ID为0，user1用户ID为1000.在root下编译这个程序为repid，此时这个程序的用户所有者ID是root，当我们以user1这个程序文件的时候，那么uid和euid的值就是user1用户的ID，因为进程保存的设置用户ID是复制有效用户ID的值，所以进程的保存的设置用户ID也是user1用户的ID。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uid=1000</span><br><span class="line">euid=1000</span><br></pre></td></tr></table></figure></p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果root用户在编译完这个程序的时候，还设置了这个程序文件的设置用户位，那么user1用户执行这个程序文件打印的东西又会不一样了。</span><br><span class="line">```bash</span><br><span class="line">uid=<span class="number">1000</span></span><br><span class="line">euid=<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>可以看到进程的有效用户ID被设置成了root用户的ID，也就是这个程序文件的所有者用户ID。对于此时的进程的保存的设置用户ID也是0。此时这个进程能够以root权限访问资源。<br>进程除了在初始化的时候，会设置这些ID之外，在执行过程中能够调用setuid和seteuid函数来设置实际用户ID和有效用户ID。</p>
<ol>
<li>若进程具有超级用户特权，则setuid函数讲实际用户ID，有效用户ID以及保存的设置用户ID设置为uid(这个uid是setuid函数的参数)。如果这个进程是调用setuid来设置有效用户ID，那么只会修改这个进程的有效用户ID，其他ID保持不变。</li>
<li>若进程没有超级用户特权，但是uid等于实际用户ID或保存的设置用户ID，则setuid只将有效用户ID设置为uid。如果这个进程是调用seteuid来设置有效用户ID，那么也是只能设置为其实际用户ID或保存的设置用户ID。</li>
</ol>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/10/31/非阻塞connect/" itemprop="url">
                非阻塞connect
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-10-31T15:50:07+08:00" content="2015-10-31">
            2015-10-31
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/linux系统编程/" itemprop="url" rel="index">
                  <span itemprop="name">linux系统编程</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/10/31/非阻塞connect/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/31/非阻塞connect/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>对一个非阻塞TCP套接字调用connect，那么这个connect就变成了非阻塞的connect。<br>当调用非阻塞connect，connect将立即返回一个EINPROGRESS错误，不过已经发起的TCP三鹿握手继续进行。这么做的好处首先就是在TCP三次握手阶段，进程不用一直阻塞在connect系统调用上，进程可以暂时做些其他事情，connect相当于发起了连接的作用。那么我们怎么知道TCP连接成功建立了呢？</p>
<ol>
<li>尽管TCP套接字是非阻塞的，如果连接到的服务器在同一主机上，那么当我们调用connect时，连接通常立刻建立。connect会返回0，表明连接立即建立成功了。</li>
<li>对于连接不能立即建立的，我们可以在后续的过程通过一些I/O复用函数来知道连接是否成功还是出错了，如select，epoll。当连接成功建立时，描述符变为可写。当连接建立遇到错误时，描述符变为既可读又可写。<br>但是我们要需要特别注意的是：<br>当一个TCP成功建立，并且对端已经发送了一些数据来的时候也会使得非阻塞套接字变得可读可写。非阻塞套接字连接出错也会使得套接字变得可读可写。所以当一个非阻塞TCP套接字变得可读可写的时候，我们需要通过调用getsockopt获取SO_ERROR的值来检查套接字上是否存在待处理错误来处理这种情形。<br>除了调用getsockopt来获取套接字的错误可以判断套接字是否建立成功，还可以用如下方法；<br><img src="/images/connect.png" alt="其他方法判定非阻塞connect连接成功"></li>
</ol>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/10/30/ipv4ipv6/" itemprop="url">
                ipv4ipv6
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-10-30T16:00:08+08:00" content="2015-10-30">
            2015-10-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/linux系统编程/" itemprop="url" rel="index">
                  <span itemprop="name">linux系统编程</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/10/30/ipv4ipv6/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/30/ipv4ipv6/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>下面成立的条件是主机是双栈主机，也就是同时支持IPv4协议和IPv6协议。<br>双栈主机上的IPv6服务器既能够服务于IPv4客户，又能够服务于IPv6客户。IPv4客户发送给这种服务器的仍然是IPv4数据报，不过服务器的协议栈会把客户主机的地址转换成一个IPv4的映射的IPv6地址，因此IPv6服务器仅仅处理IPv6套接字地址结构。<br>类似地，双栈主机上的IPv6客户能够和IPv4服务器通信。客户的解析器会把服务器主机所有的A记录作为IPv4映射的IPv6地址返回给客户，而客户指定这些地址之一调用connect将会使双栈发送一个IPv4 SYN分节。<br>IN6_IS_ADDR_V4MAPPED宏可用于判定对端是否在使用IPv4.</p>
<h4 id="IPv4客户与IPv6服务器"><a href="#IPv4客户与IPv6服务器" class="headerlink" title="IPv4客户与IPv6服务器"></a>IPv4客户与IPv6服务器</h4><p>其中的IPv6服务器主机是双栈主机。双栈主机的一个基本特性是其上的IPv6服务器既能处理IPv4客户，又能处理IPv6客户。这是通过使用IPv4映射的UPv6地址实现的。</p>
<ol>
<li>IPv6服务器启动后创建一个IPv6的监听套接字，假定服务器把通配地址绑定到该套接字上。</li>
<li>IPv4客户调用getaddrinfo函数获取IPv6服务器主机的信息。服务器既有A记录(IPv4类型的地址记录)又有AAAA记录(IPv6类型的地址记录)，但是IPv4客户只会用到查找到的A记录。</li>
<li>IPv4客户利用找到的服务器主机的A记录地址调用connect，发送IPv4 SYN到服务器主机。</li>
<li>服务器主机接收到这个目的地为IPv6监听套接字的IPv4 SYN，设置一个标志指示本连接应使用IPv4映射的IPv6地址，然后响应一个IPv4 SYN/ACK。该连接建立后，由accept返回给服务器的地址就是这个IPv4银蛇的IPv6地址。</li>
<li>以后客户主机和服务器主机都是通过IPv4数据报进行通信，底层由服务器主机的IP协议栈进行IPv4到IPv6地址映射转换。<br>可以看到上面的描述都是假设IPv6服务器必须是一个双栈主机：既有一个IPv4地址，又有一个IPv6地址。<br>大多数双栈主机在处理监听套接字时使用以下规则：</li>
<li>IPv4监听套接字只能接受来自IPv4客户的外来连接。</li>
<li>如果服务器有一个绑定了通配地址的IPv6监听套接字，而且该套接字未设置IPv6_V6ONLY套接字选项，那么该套接字既能接受来自IPv4客户的外来连接，又能接受来自IPv6客户的外来连接。</li>
<li>如果服务器有一个IPv6监听套接字，而且绑定在其上的是除IPv4映射的IPv6地址之外的某个非通配的IPv6地址，或者绑定在其上的是通配地址，不过还设置了IPv6_V6ONLY套接字选项，那么该套接字只能接受来自IPv6客户的外来连接。<h4 id="IPv6客户与IPV4服务器"><a href="#IPv6客户与IPV4服务器" class="headerlink" title="IPv6客户与IPV4服务器"></a>IPv6客户与IPV4服务器</h4>对于这种情况，和上面的情况类似，只不过这里客户主机必须是双栈主机，而地址的转换也是在客户主机上IP协议栈负责的。</li>
</ol>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/10/27/大端和小端字节序/" itemprop="url">
                大端和小端字节序
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-10-27T19:43:49+08:00" content="2015-10-27">
            2015-10-27
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/linux系统编程/" itemprop="url" rel="index">
                  <span itemprop="name">linux系统编程</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/10/27/大端和小端字节序/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/27/大端和小端字节序/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>考虑存储一个2个字节的整数。内存中存储这两个字节有两种方法：一种是将低序字节存储在起始地址，这称为小端(litter-endian)字节序；另一种方法是将高序字节存储在起始地址，这成为大端(big-endian)字节序。<br><img src="/images/byteorder.png" alt="2个字节的整数小端和大端字节序存储"><br>我们把某个给定系统所用的字节序成为主机字节序(host byte order)。对于不同的系统来说，他们的字节序都有可能不同。网络传输数据的时候，也必须指定一个字节序，网络传输采用大端字节序来传送数据。所以在主机和网络中交换数据要进行字节序的转换。<br>在linux系统中定义了一系列函数用来在网络和主机之间的字节序的转换函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="keyword">uint16_t</span> htons(<span class="keyword">uint16_t</span> hostshort);</span><br><span class="line"><span class="keyword">uint32_t</span> htonl(<span class="keyword">uint32_t</span> hostlong);</span><br><span class="line"><span class="keyword">uint16_t</span> ntohs(<span class="keyword">uint16_t</span> netshort);</span><br><span class="line"><span class="keyword">uint32_t</span> ntohl(<span class="keyword">uint32_t</span> netlong);</span><br></pre></td></tr></table></figure></p>
<h2 id="在这些函数的名字中，h代表host，n代表network，s代表short，l代表long。"><a href="#在这些函数的名字中，h代表host，n代表network，s代表short，l代表long。" class="headerlink" title="在这些函数的名字中，h代表host，n代表network，s代表short，l代表long。"></a>在这些函数的名字中，h代表host，n代表network，s代表short，l代表long。</h2><p>下面这个函数可用来检测你的主机是什么主机字节序的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">	<span class="keyword">union</span>&#123;</span><br><span class="line">	    <span class="keyword">short</span> s;</span><br><span class="line">	    <span class="keyword">char</span> c[<span class="keyword">sizeof</span>(<span class="keyword">short</span>)];</span><br><span class="line">    &#125;un;</span><br><span class="line">    un.s=<span class="number">0x0102</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">sizeof</span>(<span class="keyword">short</span>)==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(un.c[<span class="number">0</span>]==<span class="number">1</span> &amp;&amp; un.c[<span class="number">1</span>]==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"big-endian\n"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(un.c[<span class="number">0</span>]==<span class="number">2</span> &amp;&amp; un.c[<span class="number">1</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"little-endian\n"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"unkown\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"sizeof(short)=%d : 请做相应的修改\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">short</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/10/27/TCP经受时延的确认算法和Nagl算法/" itemprop="url">
                TCP经受时延的确认算法和Nagle算法
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-10-27T15:38:32+08:00" content="2015-10-27">
            2015-10-27
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/linux系统编程/" itemprop="url" rel="index">
                  <span itemprop="name">linux系统编程</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/10/27/TCP经受时延的确认算法和Nagl算法/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/27/TCP经受时延的确认算法和Nagl算法/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>TCP中这两个算法的目的都是为了减少在网络中的分组数目，减少网络的负载，特别是当小分组数目很多的时候。</p>
<h4 id="经受时延的确认"><a href="#经受时延的确认" class="headerlink" title="经受时延的确认"></a>经受时延的确认</h4><p>经受时延的确认(delayed ACK)算法是当TCP在接收到数据的时候并不立即发送ACK确认给对端，相反，它推迟发送ACK，以便将ACK与要发送的数据一起发送给对端。当然这个推迟也不是无限推迟，在RFC中描述为推迟的时间一定要小于500ms。<br>这个算法的好处就是，当一方发送的分组都是一些小分组的时候，那么另一方就要频繁对小分组发送确认，而如果采用经受时延的确认，则确认就包含在了数据分组里面，减少了分组的数目。</p>
<h4 id="Nagle算法"><a href="#Nagle算法" class="headerlink" title="Nagle算法"></a>Nagle算法</h4><p>对于一些交互式的应用，经常发送一些只有一个或者几个字节的数据就要发送一个分组，那么一个分组中的有效数据就很少，更多的是一些额外的字节，如20字节的IP首部，20字节的TCP首部。这些额外的字节比有效的数据多得多，如果频繁发出这些小分组，那么很可能就会造成网络拥塞。一种简单和好的方法就是采用Nagle算法。<br>该算法要求一个TCP连接上最多只能有一个未被确认的未完成的小分组，在该分组的确认到达之前不能发送其他的小分组。相反，TCP会在确认到达之前，收集这期间要发送的少量的分组，并在确认到来时以一个分组的方式发送出去。<br>可以看到通过Nagle算法，可以节省很多网络带宽。特别是当确认到达的时间要很久的时候，说明这时候网络状况不是很好，而如果还继续频繁的发送小分组则更会造成网络拥塞，而如果采用Nagle算法，则可以收集小分组以一个大的分组形式一次发出，减少了要发送的分组的数量，节约了网络的带宽。</p>
<h4 id="TCP-NODELAY选项"><a href="#TCP-NODELAY选项" class="headerlink" title="TCP_NODELAY选项"></a>TCP_NODELAY选项</h4><p>我们经常在一些网络程序中看到这些代码:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> yes=<span class="number">1</span>;</span><br><span class="line">setsockopt(fd,IPPROTO_TCP,TCP_NODELAY,&amp;yes,siezof(yes));</span><br></pre></td></tr></table></figure></p>
<p>这是设置socket选项的函数。其中TCP_NODELAY的作用就是关闭Nagle算法。当Nagle算法和经时延的确认算法在一起工作的时候，就要出一些问题了，此时我们要关闭Nagle算法。<br>关闭Nagle算法的目的很明显就是要当有要发送的分组，不管分组是大还是小，应该立即发送出去，不管前面有没有未被确认的分组。<br>我们先看下当这两种算法同时作用的情况：<br><img src="/images/nagle.png" alt="经时延的确认和Nagle算法"><br>上面是一个client和server交互的情形，client发送数据给server，然后server并不马上发送确认回去，而是等待自己要有数据发送了在和确认一起发送给client(经时延的确认)。同时client端在等待第一个数据的确认的期间，也不发送数据给server(Nagle)，而是收集这些数据数据，直到收到确认后再一个大分组的形式发送给server，当然其中也包括了对server端数据的确认。<br>这看起来好像并没有什么问题，但是现实中兵不是所有的数据流都是这样的。在来看看下面这种client和server的交互数据流：<br><img src="/images/nagle_2.png" alt="要关闭Nagle算法的情况"><br>从上面我们可以看到矛盾的地方：server端要求更多的数据才能工作，而client端由于Nagle算法的原因在没收到第一个数据的确认并不会马上发送数据给server，而此时server正在等待更多的数据，才会产生数据给client，所以第一个数据的确认只能等待超出经延迟确认算法的延迟时间后，才会发送给client。<br>所以可以看到当碰到这种交互的时候，会发生这种情况，server端等待进一步的数据到达才会产生数据，并和确认发送给client，而client由于Nagle算法，由于没有收到确认却迟迟不发送更多的数据给server。那么这样会造成client每次发送数据都要推迟经时延的确认算法规定的时延这么多时间才会发送出去。很明显这是不能忍受的，所以我们有时候要关闭Nagle算法，不必等候前一个分组的确认就把数据发送出去。(把这种交互叫做Write-Write-Read模式，因为client至少发送两个分组数据才会从server端读一次数据)</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/10/27/TCP连接请求队列/" itemprop="url">
                TCP连接队列
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-10-27T10:03:27+08:00" content="2015-10-27">
            2015-10-27
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Linux系统编程/" itemprop="url" rel="index">
                  <span itemprop="name">Linux系统编程</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/10/27/TCP连接请求队列/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/27/TCP连接请求队列/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listen(fd,BACKLOG);</span><br></pre></td></tr></table></figure>
<p>listen函数建立了一个监听接口，其中BACKLOG参数指明了TCP已完成连接队列上的连接数。<br>监听接口一端中已完成连接队列上的连接是已被TCP接受的连接(三次握手成功，即TCP连接处于ESATABLISHED状态)，但还没有被应用层所接受(accept)。<br>特别注意的是TCP接受一个连接是将其放入已完成连接队列上，而应用层接受连接时将其从已完成连接队列中移出。<br>对于新的连接请求，该TCP监听接口的端点的连接队列中还要空间，则把完成的TCP连接放入该队列。<br>应用层调用accept函数从队列中获取成功连接的TCP连接，队列中以连接数目减一。<br>特别注意的是，当连接队列已满时，但是还有连接请求到达时，那么TCP是怎么处理的？<br>我在Linux机器上测试的结果是：当队列已满，但是还有新的连接请求到达时，TCP会自动把队列中的已完成的连接移出，空出空间来给新的连接。<br>最后要注意的是，实际中队列的长度等于BACKLOG的值加一，这可能是考虑了当BACKLOG为0的情况，也就是队列中能够容纳的连接数目至少为1.</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">&raquo;</a>
  </nav>

 </div>

        

        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/xiaohuangren.png" alt="龙雄球" itemprop="image"/>
          <p class="site-author-name" itemprop="name">龙雄球</p>
        </div>
        <p class="site-description motion-element" itemprop="description">丑霸一枚</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">23</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">4</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">龙雄球</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"iovcc"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     

    
  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
