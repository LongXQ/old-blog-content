<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="丑霸一枚" />



  <meta name="keywords" content="Hexo,next" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="丑霸一枚">
<meta property="og:type" content="website">
<meta property="og:title" content="坚持锻炼">
<meta property="og:url" content="http://iovcc.com/page/2/index.html">
<meta property="og:site_name" content="坚持锻炼">
<meta property="og:description" content="丑霸一枚">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="坚持锻炼">
<meta name="twitter:description" content="丑霸一枚">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'post'
  };
</script>

  <title> 坚持锻炼 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  

  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?5ba8d0a18b1ab8a44c3c0e6556c5017f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">坚持锻炼</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            <i class="menu-item-icon icon-next-categories"></i> <br />
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            <i class="menu-item-icon icon-next-commonweal"></i> <br />
            公益404
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/10/27/TCP连接队列/" itemprop="url">
                TCP连接队列
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-10-27T09:22:55+08:00" content="2015-10-27">
            2015-10-27
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/10/27/TCP连接队列/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/27/TCP连接队列/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"></span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/10/25/当socket关闭后的读写问题/" itemprop="url">
                TCP关闭后的读写总结
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-10-25T20:31:30+08:00" content="2015-10-25">
            2015-10-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Linux系统编程/" itemprop="url" rel="index">
                  <span itemprop="name">Linux系统编程</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/10/25/当socket关闭后的读写问题/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/25/当socket关闭后的读写问题/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>一个TCP连接，相当于建立两条独立的通信管道，两端可以进行全双工通信，能够进行读和写。<br><img src="/images/TCP连接.jpg" alt="一个TCP连接"></p>
<h4 id="调用close系统调用关闭"><a href="#调用close系统调用关闭" class="headerlink" title="调用close系统调用关闭"></a>调用close系统调用关闭</h4><p>主机A调用close系统调用，相当于发送FIN报文段给B，通知它自己要关闭A到B的写管道了。B收到FIN报文段后，发送ACK确认报文段给A，说明它知道了。<br>然后B在自己执行被动关闭，关闭自己这端的管道。这样一条TCP连接就被完整的关闭了，在两端也就不存在了。那当对通过close系统关闭的TCP进行读和写会发生什么了。<br><img src="/images/close_1.png" alt="对一个已经关闭的socket进行写操作"><br>server端对一个已经关闭的socket调用了两次send写操作：(1)处的send将会把数据发送给client，由于连接已经被关闭，此时client处已经没有和server的连接了，所以client将会发送一个RST报文段给server，表明出现了一个错误。但是(1)处的send还是会调用成功的，由于收到了一个RST所以(2)处的send将会返回-1，表明发送失败，同时会触发一个SIGPIPE信号，这个信号默认的处理函数是终结进程，一般的话我们是选择忽略这个信号。<br>如果server调用读操作的话，由于已经关闭了连接，读操作一直会返回0，表明没有数据可读了。</p>
<h4 id="调用shutdown函数执行半关闭"><a href="#调用shutdown函数执行半关闭" class="headerlink" title="调用shutdown函数执行半关闭"></a>调用shutdown函数执行半关闭</h4><p>如果对一个连接的TCP调用shutdown执行半关闭的话<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown(fd,SHUT_WR);</span><br></pre></td></tr></table></figure></p>
<p>那么由于只关闭了一端的通信管道，所以另一端仍然可以进行写操作。<br><img src="/images/close_2.png" alt="对一个半关闭的连接执行读写操作"><br>client执行了半关闭，这说明client发送了FIN报文段给server，并且server也发送了ACK报文段给client进行了确认，表明client到server的这一条通信管道已经关闭了。<br>server端(1)处的send能够调用成功，因为server发送数据给client是通过server到client这一条管道<br>，而这条管道并没有关闭，于此同时client(4)的recv也能正常接收数据，因为recv也是从server到client这条管道接收数据。server端(2)处的recv则会返回0，因为client到server管道已经关闭，已经没有数据可读了。client端(3)处的send写则会失败，因为client到server的写管道已经被关闭，不能进行写了，所以返回-1，并且触发一个SIGPIPE信号给client，默认处理是终结client进程。</p>
<h4 id="对处于半打开状态的连接执行读写操作"><a href="#对处于半打开状态的连接执行读写操作" class="headerlink" title="对处于半打开状态的连接执行读写操作"></a>对处于半打开状态的连接执行读写操作</h4><p>如果一方已经关闭或异常终止连接而另一方却还不知道，我们将这样的TCP连接成为半打开的。任何一端的主机异常都可能导致发生这种情况。只要不打算在版打开的连接上进行写操作，仍处于连接状态的一方就不会检测到另一方已经出现异常。<br>这其实很好理解。我们知道不管完整的关闭还是半关闭，都要发送FIN报文段，和确认ACK报文段。这就是通知对端该TCP连接关闭了，所以如果主机出现异常情况，在关闭的情况下却没有发送这些报文段，那么对端肯定不知道出现异常的主机已经关闭连接了，它还会认为连接在网络中是正常的。<br>出现半打开的情况最长见的情形就是当client端突然掉电而不是正常的结束client应用程序后再关机。如果一个server的很多client发生这种情况，那么就会出现很多半打开的TCP连接，而server一般不会主动写数据给client，所以也不会检查到错误发生了，这样server端的半打开TCP连接就会累积的越来越多(通过设置TCP的keeplive选项能够使TCP的一端发现另一段已经消失)。<br>如果client断电关机后重启，server端对这个半打开的TCP连接进行写数据到重启的client，由于client重启前的所以的连接信息都丢失了，client发送一个RST报文段给server，server端收到RST报文后将会终止连接了，TCP连接半打开的状态就不存在了。如果server只是对这个半打开的TCP连接进行读操作，那么server可能永远不会知道client端的TCP已经关闭了。</p>
<h4 id="RST报文"><a href="#RST报文" class="headerlink" title="RST报文"></a>RST报文</h4><p>RST表示复位，用来异常的关闭连接。发送RST报文关闭连接时，不必等缓存区中的包都发出去，直接就丢弃缓存区的包发送RST报文。而接收端在收到RST报文后，也不必发送ACK报文来确认。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/10/23/TCP-WAIT/" itemprop="url">
                TIME_WAIT状态
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-10-23T09:33:52+08:00" content="2015-10-23">
            2015-10-23
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Linux系统编程/" itemprop="url" rel="index">
                  <span itemprop="name">Linux系统编程</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/10/23/TCP-WAIT/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/23/TCP-WAIT/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>TCP连接是全双工连接，类似于下面：<br><img src="/images/time_wait.png" alt="TCP全双工连接"><br>上图中表示主机A和B通过TCP建立了全双工连接，也就是任意一端都可以发送和接收数据。<br>当主机A和B建立成功后，A和B就处于ESTABLISHED状态了。当一端主动调用close系统调用来关闭TCP连接，系统就处于关闭阶段了：<br><img src="/images/time_wait1.png" alt="关闭TCP连接"><br>我们忽略了关闭过程中的中间一些状态。<br>主动关闭一方最后处于TIME_WAIT状态的时间一般为2MSL。MSL是最长分节生命，也就是一个IP数据报在网络中能够生存的最长时间。为了解释为什么TIME_WAIT状态时间为2MSL，而不是MSL或者当发送完最后一个ACK立马就关闭成功，我们假设下面两种情况。</p>
<ol>
<li>对端没有成功接收最后一个ACK，那么对端就会认为它前面发送的FIN报文对端没有成功接收，那么它就会重发FIN报文，然后继续等待ACK。我们算下重发FIN报文到对端接收重发的FIN报文要多久时间。首先主动关闭一方发送ACK，那么ACK报文最长的生存时间为MSL，当对端到一个报文的最长生命周期内还没有收到ACK报文，它肯定就是重发FIN报文，那么FIN报文传送过来的最长时间也是MSL，所以为了确保最后一个ACK成功发送给了对端，TIME_WAIT状态的持续时间为2MSL。</li>
<li>当最后一个ACK报文对端成功接收后，算是关闭成功了，但是有可能对端在收到最后一个ACK报文前，它前面发送的一些数据还没有到达对方，那么就会出现一些问题。假如我们close调用后，马上又建立一个和前面一样的TCP连接，那么这部分后达到的数据就会被新建立的TCP连接接收到，这很明显是错误的，所以关闭一个TCP连接时，还要有一个TIME_WAIT状态保证该TCP连接阶段所有的数据都在网络中不存在了，因为我们知道TIME_WAIT持续的时间为2MSL，那么在这段时间内，和该TCP连接有关的所有数据肯定都会消亡的。这样就不会被新建的TCP连接接收到了。</li>
</ol>
<p>上面的情况2要成立，要保证地址不能复用，就是当一个地址处于TIME_WAIT状态的时候，新建一个socket的地址不能和它一样。系统默认就是这样处理，但是我们也可以关闭这个，允许地址可以复用，也就是处于TIME_WAIT状态的地址可以被新建的socket复用，只要设置SO_REUSEADDR选项就可以了，但是如果这样就不能完全保证上面的情况2了。</p>
<p>从上面看到，close系统调用时关闭了两端，但是很多情况下，我们只想关闭一端，而允许另外一端接着发送数据：<br><img src="/images/time_wait2.png" alt="单通道关闭"><br>从图中可以看到我们只关闭了A端的写入口，当关闭了A端后，如果B还要读，那么会接收到FIN，表明已经没有数据可以读了。但是B端还可以进行写，A端还可以从B端接收数据。<br>我们用shutdown系统调用可以实现上面的功能。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> howto)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>howto可以为SHUTRD,SHUT_WR,SHUTRDWE，分别为关闭sockfd的读端，写端，读写端(和close一样)。<br>当关闭一个socket的读端后，接收缓冲区里面的数据全都被丢弃，以后不能调用任何读函数了。但是该socket还是可以接收对端发送来的数据并发送确认，但是之后不会交给进程，而是会悄然丢弃掉。从这里我们可以看到关闭写端并没有实质的进行关闭，也就是不会发送FIN之类的给对端，所以对端还能正常发送数据。</p>
<p>从上面可以看到一个成功的关闭要包含发送FIN，接收ACK这过程，也就是说如果没有包含这一个过程就算异常退出。<br>如果一端程序突然奔溃或者关闭阶段某一步出现错误，如果对方继续读写对端，会导致奔溃的一端TCP发送RST重置连接，表明出现了错误重置。对于写则还会抛出一个SIGPIPE异常的</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/10/13/SIGPIPE信号/" itemprop="url">
                SIGPIPE信号
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-10-13T20:37:04+08:00" content="2015-10-13">
            2015-10-13
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Linux系统编程/" itemprop="url" rel="index">
                  <span itemprop="name">Linux系统编程</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/10/13/SIGPIPE信号/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/13/SIGPIPE信号/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>当一个进程向某个已经收到RST的套接字执行写操作的时候，内核会向该进程发送一个SIGPIPE信号。该信号的默认行为是终止进程，因此进程必须捕获它以免不情愿地被终止，或者可以简单的忽略该信号：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signal(SIGPIPE,SIG_IGN);</span><br></pre></td></tr></table></figure></p>
<p>我用一个服务器进程和一个客户端进程来测试SIGPIPE。首先我们在客户端掉用close，来执行关闭TCP的连接。然后再服务器进程向这个已经被客户端关闭的TCP连接上执行写操作。<br><img src="/images/sigpipe.png" alt="SIGPIPE"><br>我们在时间点1关闭了客户端的TCP连接，然后分别在时间点2和3在服务器端向客户端执行了写操作，然后触发了SIGPIPE信号，服务器进程退出。<br>按理来说两次写操作应该返回-1才对，因为客户端已经关闭了TCP连接了，但是每次测试的时候都是不同的。有的时候是返回-1，有的时候确是返回要写入的字节数。下面我们来看看原因。<br><img src="/images/sigpipe_2.png" alt="一次TCP关闭"></p>
<ol>
<li>第一次写返回-1的情况。第一次写返回-1的情况是写的时间在上图中的(2)处，可以看到在这个时间上，TCP连接已完全关闭，所以返回-1。但是TCP还是允许这次把数据发送出去，然后客户端因为TCP已经关闭了，返回RST报文给服务器。在服务器第二次写的时候，由于收到了RST，内核触发一个SIGPIPE信号给服务器进程。服务器进程终止。</li>
<li>第一次写返回要写入的字节数。这种情况是因为服务器执行写操作是的时间点发生在(0)处或者(1)处，可以看到，这时候服务器端要么不知道客户端要执行关闭操作了，要么就是TCP处于半关闭的状态。不管哪种情况服务器仍然可以向客户端写数据的，所以返回写入的字节数(注意这里的写入是写入了服务器进程成功写入发送缓冲区)，但是在数据真正发送给客户端前，TCP连接已经完全关闭，所以第一次写入到客户端的数据被客户端TCP接收后，客户端TCP返回RST给服务端。然后第二次写就会触发SIGPIPE信号。</li>
</ol>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/10/13/fcntl-ioctl-setsockopt使用说明/" itemprop="url">
                fcntl ioctl setsockopt使用说明
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-10-13T16:26:58+08:00" content="2015-10-13">
            2015-10-13
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Linux系统编程/" itemprop="url" rel="index">
                  <span itemprop="name">Linux系统编程</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/10/13/fcntl-ioctl-setsockopt使用说明/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/13/fcntl-ioctl-setsockopt使用说明/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>写程序的时候经常搞不清fcntl，ioctl和setsockopt的区别，而且其中每一个函数的参数也是这么多，所以作下笔记给以后写程序的时候参考参考。<br>我们都知道Linux(unix)中所有的东西都是文件，Linux把大部分东西都虚拟成了一个文件，也就是平常我们写程序一般都是基于在VFS(虚拟文件系统)之上的。通过VFS和硬件打交道。<br><img src="/images/VFS.png" alt="VFS模型"></p>
<h3 id="fcntl函数"><a href="#fcntl函数" class="headerlink" title="fcntl函数"></a>fcntl函数</h3><p>fcntl函数作用在VFS层，它控制文件系统的一些参数，如文件访描述符标志，文件状态标志等。<br><strong>F_GETFD</strong><br>    读取文件描述符标志<br><strong>F_SETFD</strong><br>    设置文件描述符标志<br>    现阶段指支持这一个标志:FD_CLOEXEC(close-on-exec)，这个标志的作用是在执行exec的时候在子进程中关闭设置了FD_CLOEXEC的fd，这个标志也可以在open函数在打开一个文件的时候使用O_CLOEXEC。<br><strong>F_GETFL</strong><br>    读取文件访问权限和文件状态标志。<br><strong>F_SETFL</strong><br>    虽然F_GETFL能够读取到文件的访问权限，但是不能用fcntl设置他们。<br>    <strong>O_APPEND</strong> 设置文件追加到文件末尾标志<br>    <strong>O_ASYNC</strong> 当文件能够读或者写的时候可以发送信号(SIGIO)。这个特性仅仅对终端，伪终端，sockets和pipes和FIFOs有用。<br>    <strong>O_DIRECT</strong> 直接从设备中读写<br>    <strong>O_NOATIME</strong> 不更新文件最后一次访问时间(inode中的st_atime属性)</p>
<pre><code>**O_NONBLOCK** 设置文件为非阻塞标志
</code></pre><hr>
<h3 id="ioctl函数"><a href="#ioctl函数" class="headerlink" title="ioctl函数"></a>ioctl函数</h3><h2 id="ioctl则是直接控制一些IO设备的一些属性，对设备的一些特性进行控制。如终端设备的波特率这些。ioctl和设备关系密切，所以再次就不一一列举控制参数了。一个fd能够被ioctl操作前提是fd对应的设备在驱动程序中实现了ioctl函数。"><a href="#ioctl则是直接控制一些IO设备的一些属性，对设备的一些特性进行控制。如终端设备的波特率这些。ioctl和设备关系密切，所以再次就不一一列举控制参数了。一个fd能够被ioctl操作前提是fd对应的设备在驱动程序中实现了ioctl函数。" class="headerlink" title="ioctl则是直接控制一些IO设备的一些属性，对设备的一些特性进行控制。如终端设备的波特率这些。ioctl和设备关系密切，所以再次就不一一列举控制参数了。一个fd能够被ioctl操作前提是fd对应的设备在驱动程序中实现了ioctl函数。"></a>ioctl则是直接控制一些IO设备的一些属性，对设备的一些特性进行控制。如终端设备的波特率这些。ioctl和设备关系密切，所以再次就不一一列举控制参数了。一个fd能够被ioctl操作前提是fd对应的设备在驱动程序中实现了ioctl函数。</h2><h3 id="setsockopt函数"><a href="#setsockopt函数" class="headerlink" title="setsockopt函数"></a>setsockopt函数</h3><p>setsockopt函数则是专门控制socket的一些参数。它指定了在不同的level上面设置参数。<br><strong>SOL_SOCKET</strong> sockets API level<br>    SO_KEEPALIVE<br>        设置TCP的keep alive选项，去探测失效的一端<br>    SO_SNDBUF<br>        设置发送buffer<br>    SO_SNDTIMEO SO_RCVTIMEO<br>        发送或者接收超时时间，直到一个错误产生。<br>    SO_REUSEADDR<br>        重用地址端口。当一个端口关闭时，这个socket处于TIME_WAIT状态，假如我们在新建一个socket，但是又绑定处于TIME-WAIT状态的端口，则会出错，但是如果设置了这个选项，则不会出错了。<br>    SO_BROADCAST<br>        设置broadcast标志。UDP socket能够发送数据给broadcast地址，对TCP socket无效。<br>    SO_ERROR<br>        得到和清除pending socket error。<br>    SO_RCVBUF<br>        设置或得到socket接收buffer<br><strong>IPPROTO_TCP</strong><br>    TCP_KEEPIDLE<br>        如果在设置的时间内没有响应则发送心跳包检测<br>    TCP_KEEPINTVL<br>        设置发送心跳包的时间间隔<br>    TCP_KEEPCNT<br>        设置发送心跳包的次数<br>    TCP_NODELAY<br>        禁用TCP协议中的Nagle算法</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/10/13/Redis-事件处理实现/" itemprop="url">
                Redis-事件处理实现
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-10-13T15:50:26+08:00" content="2015-10-13">
            2015-10-13
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/redis/" itemprop="url" rel="index">
                  <span itemprop="name">redis</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/10/13/Redis-事件处理实现/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/13/Redis-事件处理实现/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>Redis的事件处理框架底层的实现是对epoll，kqueue，select的包装。以epoll为例来讲事件框架的实现，其他实现类似。<br>在Redis服务器启动伊始，会创建一个<code>aeEventLoop</code>结构实例。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> aeEventLoop&#123;</span><br><span class="line">    <span class="keyword">int</span> maxfd;   <span class="comment">/* highest file descriptor currently registered */</span></span><br><span class="line">    <span class="keyword">int</span> setsize; <span class="comment">/* max number of file descriptors tracked */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> timeEventNextId;</span><br><span class="line">    <span class="keyword">time_t</span> lastTime;     <span class="comment">/* Used to detect system clock skew */</span></span><br><span class="line">    aeFileEvent *events; <span class="comment">/* Registered events */</span></span><br><span class="line">    aeFiredEvent *fired; <span class="comment">/* Fired events */</span></span><br><span class="line">    aeTimeEvent *timeEventHead;</span><br><span class="line">    <span class="keyword">int</span> stop;</span><br><span class="line">    <span class="keyword">void</span> *apidata; <span class="comment">/* This is used for polling API specific data */</span></span><br><span class="line">    aeBeforeSleepProc *beforesleep;</span><br><span class="line">&#125; aeEventLoop;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>maxfd表示目前注册的最大的文件描述符fd</li>
<li>setsize表示事件库支持的最大文件描述符个数</li>
<li>events是一个数组，当前注册的所有事件在里面</li>
<li>fired是就绪事件数组，当前就绪的事件组成的一个数组<br>初始完aeEventLoop实例后，在创建一个<code>aeApiState</code>结构实例。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> aeApiState&#123;</span><br><span class="line">	<span class="keyword">int</span> epfd;</span><br><span class="line">	<span class="keyword">struct</span> epoll_event *events;</span><br><span class="line">&#125;aeApiState;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>初始化一个epoll，得到的epoll描述符赋值给aeApiState实例的epfd字段。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">epfd= epoll_create(<span class="number">1024</span>)</span><br></pre></td></tr></table></figure></p>
<p>可以看到，这样aeEventLoop就和epoll关联起来了。<br><img src="/images/aeEventLoop.png" alt="eventLoop"><br>当我们要注册一个文件读写事件时候，系统会创建一个<code>aeFileEvent</code>结构实例，代表该文件读写事件。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* File event structure */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> aeFileEvent &#123;</span><br><span class="line">    <span class="keyword">int</span> mask; <span class="comment">/* 事件掩码，表明注册的是文件读事件还是写事件，还是二者都有 */</span></span><br><span class="line">    aeFileProc *rfileProc; <span class="comment">/* 读事件处理函数 */</span></span><br><span class="line">    aeFileProc *wfileProc; <span class="comment">/* 写事件处理函数 */</span></span><br><span class="line">    <span class="keyword">void</span> *clientData;</span><br><span class="line">&#125; aeFileEvent;</span><br></pre></td></tr></table></figure></p>
<p>然后根据文件描述符fd添加到aeEventLoop实例中的events数组中去，假设这里的fd为3，也就是events[3]。<br><img src="/images/aeFileEvent.png" alt="aeFileEvent"><br>接着把该fd和fd的事件注册到epoll中去。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加事件到epoll实例中去</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiAddEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    aeApiState *state = eventLoop-&gt;apidata;</span><br><span class="line">    <span class="keyword">struct</span> epoll_event ee;</span><br><span class="line">    <span class="keyword">int</span> op = eventLoop-&gt;events[fd].mask == AE_NONE ?</span><br><span class="line">            EPOLL_CTL_ADD : EPOLL_CTL_MOD;</span><br><span class="line">    ee.events = <span class="number">0</span>;</span><br><span class="line">    mask |= eventLoop-&gt;events[fd].mask; </span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_READABLE) ee.events |= EPOLLIN; <span class="comment">/* 添加读事件 */</span></span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_WRITABLE) ee.events |= EPOLLOUT; <span class="comment">/* 添加写事件 */</span></span><br><span class="line">    ee.data.u64 = <span class="number">0</span>; </span><br><span class="line">    ee.data.fd = fd;</span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(state-&gt;epfd,op,fd,&amp;ee) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* 注册到epoll中去 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后就是调用aeApiPoll函数等待事件的发生<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待epoll实例中相关fd的事件发生，返回就绪的事件个数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiPoll</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">struct</span> timeval *tvp)</span> </span>&#123;</span><br><span class="line">    aeApiState *state = eventLoop-&gt;apidata;</span><br><span class="line">    <span class="keyword">int</span> retval, numevents = <span class="number">0</span>;</span><br><span class="line">    retval = epoll_wait(state-&gt;epfd,state-&gt;events,eventLoop-&gt;setsize,</span><br><span class="line">            tvp ? (tvp-&gt;tv_sec*<span class="number">1000</span> + tvp-&gt;tv_usec/<span class="number">1000</span>) : <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (retval &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    	当检测到有事件发生的时候，发生的事件会在state-&gt;events数组中，state-&gt;events是epoll_event结构。以前面注册的fd为<span class="number">3</span>的文件事件为例，当该fd的事件发生的时候，比如可读了或者可写了，epoll_wait便会初始化state-&gt;events[<span class="number">3</span>]结构：state-&gt;events[<span class="number">3</span>]-&gt;events=EPOLLI或者EPOLLOUT或者二者都有；state-&gt;events[<span class="number">3</span>]-&gt;data-&gt;fd=<span class="number">3</span>;</span><br><span class="line">    	接着会传递就绪事件到高层中去，也就是aeEventLoop中去，添加到对应的fired[<span class="number">3</span>]数组中。</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numevents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是<code>aeFiredEvent</code>结构：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* A fired event */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> aeFiredEvent &#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> mask;</span><br><span class="line">&#125; aeFiredEvent;</span><br></pre></td></tr></table></figure></p>
<p>mask表示对应的就绪事件，fd为就绪事件对应的文件描述符<br><img src="/images/aeEventLoop_1.png" alt="aeEventLoop"><br>这样当调用aeApiPoll函数后，就知道有哪些就绪事件可以处理了，就绪事件都存在aeEventLoop实例中的fired数组中，接下来就是一一处理fired数组中的时间了，调用注册时的注册的事件处理函数。<br>当处理完这一次调用aeApiPoll得到的事件后，Redis服务器又开始新一轮的循环，接着调用aeApiPoll函数开启下一轮事件处理。<br>至于时间事件处理基本和文件事件处理一样的。<br>下面画出了Redis服务器的事件处理流程图<br><img src="/images/aeEventLoop_2.png" alt="Redis 事件处理流程图"></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/10/12/redisDB实现/" itemprop="url">
                redisDB数据库实现
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-10-12T18:47:13+08:00" content="2015-10-12">
            2015-10-12
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/10/12/redisDB实现/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/12/redisDB实现/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>Redis数据库就是以dict数据结构实现的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> redisDb &#123;</span><br><span class="line">    dict *dict;                 <span class="comment">/* The keyspace for this DB(数据库的键空间) */</span></span><br><span class="line">    dict *expires;              <span class="comment">/* Timeout of keys with a timeout set(记录一个有生存时间限制的键) */</span></span><br><span class="line">    dict *blocking_keys;        <span class="comment">/* Keys with clients waiting for data (BLPOP)(记录了client阻塞的键) */</span></span><br><span class="line">    dict *ready_keys;           <span class="comment">/* Blocked keys that received a PUSH */</span></span><br><span class="line">    dict *watched_keys;         <span class="comment">/* WATCHED keys for MULTI/EXEC CAS */</span></span><br><span class="line">    <span class="keyword">struct</span> evictionPoolEntry *eviction_pool;    <span class="comment">/* Eviction pool of keys */</span></span><br><span class="line">    <span class="keyword">int</span> id;                     <span class="comment">/* Database ID(数据库ID，用来唯一标识这个数据库) */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl;          <span class="comment">/* Average TTL, just for stats */</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure></p>
<h2 id="一个redisDB就代表了一个Redis数据库，id记录了数据库的ID，数据存储在dict指针指向的hash-table中。"><a href="#一个redisDB就代表了一个Redis数据库，id记录了数据库的ID，数据存储在dict指针指向的hash-table中。" class="headerlink" title="一个redisDB就代表了一个Redis数据库，id记录了数据库的ID，数据存储在dict指针指向的hash table中。"></a>一个redisDB就代表了一个Redis数据库，id记录了数据库的ID，数据存储在dict指针指向的hash table中。</h2><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>当我们执行下面这条命令<br><code>LPUSH mylist longxiongqiu</code><br>Redis数据库是怎么样的呢?<br><img src="/images/redisDB.png" alt="redis数据库"><br>图中的REDIS_ENCODING_LINKEDLIST是list对象的一种对象编码，这种编码比较简单，和我们常见的linked list基本一样。<br>执行其他插入命令基本和这个一样。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/10/12/Redis-dict实现/" itemprop="url">
                Redis dict实现
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-10-12T15:37:42+08:00" content="2015-10-12">
            2015-10-12
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/redis/" itemprop="url" rel="index">
                  <span itemprop="name">redis</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/10/12/Redis-dict实现/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/12/Redis-dict实现/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>dict数据结构在Redis中是一个重要的部分，REDIS_ENCODING_HT对象编码就是用dict实现的，而且Redis的数据库也是利用dict来实现的。</p>
<h2 id="dict实现的相关数据结构"><a href="#dict实现的相关数据结构" class="headerlink" title="dict实现的相关数据结构:"></a>dict实现的相关数据结构:</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dict&#123;</span><br><span class="line">	dictType *type;</span><br><span class="line">	<span class="keyword">void</span> *privdata;</span><br><span class="line">	dictht ht[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">long</span> rehashidx;</span><br><span class="line">	<span class="keyword">int</span> iterators;</span><br><span class="line">&#125;dict;</span><br></pre></td></tr></table></figure>
<h2 id="一个dict结构里面包含了两个hash-table-ht-2-。"><a href="#一个dict结构里面包含了两个hash-table-ht-2-。" class="headerlink" title="一个dict结构里面包含了两个hash table(ht[2])。"></a>一个dict结构里面包含了两个hash table(ht[2])。</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dictht&#123;</span><br><span class="line">	dictEntry **table;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="size字段表示table数组的大小，table是一个dictEntry-数组，它的大小始终为2的倍数。used表示当前hash-table中dictEntry的个数。"><a href="#size字段表示table数组的大小，table是一个dictEntry-数组，它的大小始终为2的倍数。used表示当前hash-table中dictEntry的个数。" class="headerlink" title="size字段表示table数组的大小，table是一个dictEntry*数组，它的大小始终为2的倍数。used表示当前hash table中dictEntry的个数。"></a>size字段表示table数组的大小，table是一个dictEntry*数组，它的大小始终为2的倍数。used表示当前hash table中dictEntry的个数。</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dictEntry&#123;</span><br><span class="line">	<span class="keyword">void</span> *key;</span><br><span class="line">	<span class="keyword">union</span>&#123;</span><br><span class="line">		<span class="keyword">void</span> *val;</span><br><span class="line">		uint64_6 u64;</span><br><span class="line">		<span class="keyword">int64_t</span> s64;</span><br><span class="line">		<span class="keyword">double</span> d;</span><br><span class="line">	&#125;v;</span><br><span class="line">	<span class="keyword">struct</span> dictEntry *next;</span><br><span class="line">&#125;dictEntry;</span><br></pre></td></tr></table></figure>
<h2 id="dictEntry就是hash-table中的条目，每一个条目代表一个key-value对。"><a href="#dictEntry就是hash-table中的条目，每一个条目代表一个key-value对。" class="headerlink" title="dictEntry就是hash table中的条目，每一个条目代表一个key-value对。"></a>dictEntry就是hash table中的条目，每一个条目代表一个key-value对。</h2><p>下面是一个空的dict<br><img src="/images/dict.png" alt="空的dict"></p>
<h3 id="往空的dict中插入一个key-value对"><a href="#往空的dict中插入一个key-value对" class="headerlink" title="往空的dict中插入一个key-value对"></a>往空的dict中插入一个key-value对</h3><p>当是第一次往dict中插入元素的时候，由于dict中ht[0]和ht[1]中table数组都是空的，所以系统一开始在第一次插入元素的时候会初始化ht[0]-&gt;table，初始该table数组长度为4，并初始化数组中每一个dictEntry指针为NULL。<br><img src="/images/dict_0.png" alt="dict"><br>接着在初始化一个dictEntry，它的key字段就是key-value对中的key，它的v字段就是value。<br>然后使用hash算法算出key-value对中key对应的hash值，然后除以ht[0]-&gt;sizemask，余数就是插入的位置。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=hash(key);</span><br><span class="line"><span class="keyword">int</span> index=key%ht[<span class="number">0</span>]-&gt;sizemask;</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/dict_1.png" alt="dict"></p>
<h2 id="到此为止一个key-value对就插入到dict中了。"><a href="#到此为止一个key-value对就插入到dict中了。" class="headerlink" title="到此为止一个key-value对就插入到dict中了。"></a>到此为止一个key-value对就插入到dict中了。</h2><h3 id="rehash过程"><a href="#rehash过程" class="headerlink" title="rehash过程"></a>rehash过程</h3><p>当ht[0]中的元素太多的时候，dict就会进行扩大hash table。但是这里的扩大不是指扩大原有的ht[0]的大小，而是新初始化一个更大的hash table，并让ht[1]-&gt;table指向它。新的分配的hash table的大小是在ht[0]-&gt;used的两倍的基础上调整为2的倍数。<br><img src="/images/dict_2.png" alt="dict"><br>我们可以看到ht[0]中当前有30个元素，dict新建了一个size等于60的hash table并让ht[1]-&gt;table指向它。<br>为什么要这么做？这么做的目的就是进行rehash。那为什么又要rehash呢？<br>原因就是当ht[0]-&gt;table中的元素越来越多的时候，会导致定位当某一个元素越来越费时间，导致效率变低。所以必须要重新rehash到一个更大的hash table中去，使得元素均匀分布在hash table中。所以这就是为什么dict需要两个dictht结构的原因。ht[1]就是用来rehash的。<br>当ht[1]-&gt;table准备就绪后，就可以开始进行rehash了，rehash过程就和插入一个元素到ht[0]-&gt;table中去差不多，就是把ht[0]-&gt;table中的每一个元素的key值重新hash一次，然后再插入到ht[1]-&gt;table中来。<br><img src="/images/dict_3.png" alt="dict"><br>当ht[0]-&gt;table中的所有元素都被rehash到ht[1]-&gt;table中去，则释放掉ht[0]-&gt;table数组，然后让ht[0]-&gt;table指向ht[1]-&gt;table，调整ht[0]其他字段的值并对ht[1]进行重置操作。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="/images/dict_4.png" alt="dict"></h2><h3 id="逐次rehash操作"><a href="#逐次rehash操作" class="headerlink" title="逐次rehash操作"></a>逐次rehash操作</h3><p>dict并不是一次性把ht[0]-&gt;table中的所有元素rehash到新的hash table中去的，因为当旧table中元素太多的时候，这样很费时间，所以dict采取的是逐次rehash。一次rehash过程有可能rehash掉ht[0]-&gt;table[0]中的所有元素，有可能还会rehash掉ht[0]-&gt;table[1]中的所有元素，但是不会rehash掉所有的，也不会rehash掉ht[0]-&gt;table[1]中的一部分元素就退出了，要么rehashht[0]-&gt;table[1]中的所有的元素要么就不会rehash。<br>dict结构的rehashidx字段记录了目前rehash过程到哪一个ht[0]-&gt;table数组中的元素了。当全部rehash操作完成，rehashidx字段重置为-1。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/10/12/Redis-Intset实现/" itemprop="url">
                Redis Intset实现
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-10-12T09:24:21+08:00" content="2015-10-12">
            2015-10-12
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/redis/" itemprop="url" rel="index">
                  <span itemprop="name">redis</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/10/12/Redis-Intset实现/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/12/Redis-Intset实现/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>Redis Intset结构是用来实现REDIS_ENCODING_INTSET对象编码的。当一个Redis set对象中所有的元素都是整数的时候适合用REDIS_ENCODING_INTSET对象编码来存储。<br>不同于数组，Intset能够存储不同字节长度的整数，并且是按照有序的方式存到intset结构中来的。</p>
<h3 id="Intset结构"><a href="#Intset结构" class="headerlink" title="Intset结构"></a>Intset结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> intset&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> encoding;</span><br><span class="line">	<span class="keyword">uint32_t</span> length;</span><br><span class="line">	<span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125;intset;</span><br></pre></td></tr></table></figure>
<p>length字段表示目前intset结构中有多少个元素。<br>contents为占位符，代表元素的起始地址。<br>Intset结构中的encoding字段可以有以下的取值:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t))</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>INTSET_ENC_INT16表示当前intset结构中的元素按照16位的整数来存储的</li>
<li>INTSET_ENC_INT32表示当前intset结构中的元素按照32位的整数来存储的</li>
<li>INTSET_ENC_INT64表示当前intset结构中的元素按照64位的整数来存储的</li>
</ol>
<hr>
<p>特别注意的是，encoding字段取值只能前进不能倒退，意思就是如果如果当前encoding字段的值是INTSET_ENC_INT32，那么就不能在给encoding赋值为INTSET_ENC_INT16了，只能保持不变或者赋值为INTSET_ENC_INT64。</p>
<h3 id="新建一个Intset结构"><a href="#新建一个Intset结构" class="headerlink" title="新建一个Intset结构"></a>新建一个Intset结构</h3><p>新建一个Intset结构时，默认的encoding字段设置为INTSET_ENC_INT16，表示当前intset结构中的整数按照16位整数来进行存取，初始的时候长度为0所以length字段设置为0<br><img src="/images/emptyintset.png" alt="empty intset"></p>
<h3 id="Intset元素插入"><a href="#Intset元素插入" class="headerlink" title="Intset元素插入"></a>Intset元素插入</h3><p>当插入一个整数的时候，首先intset会检查该整数的最小编码方式，看最小能够用多少个字节来存储这个整数，如果能够用2个字节来存储这个整数，则这个整数的最小编码就是INTSET_ENC_INT16，如果要用4个字节来存储，最小编码就是INTSET_ENC_INT32，如果要用8个字节来存储，最小编码就是INTSET_ENC_INT64。</p>
<h5 id="插入最小编码为INTSET-ENC-INT16的整数"><a href="#插入最小编码为INTSET-ENC-INT16的整数" class="headerlink" title="插入最小编码为INTSET_ENC_INT16的整数"></a>插入最小编码为INTSET_ENC_INT16的整数</h5><p>刚开始时，encoding字段也是INTSET_ENC_INT16，所以intset会按照encoding的方式来存储这个整数。<br>首先在intset中查找当前整数是否已经在intset中了，如果已经存在则不插入，如果不存在则分配两个字节的空间给新元素，找到插入点，然后插入进去。由于刚开始时，intset为空，所以直接插入到第一个位置。<br><img src="/images/INTSET_ENC_INT16.png" alt="INTSET_ENC_INT16"><br>我们在插入一个INTSET_ENC_INT16的整数。首先调整intset的大小，新分配两个字节的空间，在找到待插入点，假设当前元素比intset中存在的元素小，那么应该把待插入的元素插入到起始位置，所以首先要进行数据移位，然后再插入。<br><img src="/images/INTSET_ENC_INT16_1.png" alt="INTSET_ENC_INT16"></p>
<h5 id="插入一个最小编码为INTSET-ENC-INT32的整数"><a href="#插入一个最小编码为INTSET-ENC-INT32的整数" class="headerlink" title="插入一个最小编码为INTSET_ENC_INT32的整数"></a>插入一个最小编码为INTSET_ENC_INT32的整数</h5><p>因为插入的元素要用4个字节存储，如果还是按照原先的encoding方式进行内存分配和移动位置的话，显然覆盖掉原先的元素。<br>首先intset把encoding赋值为新值INTSET_ENC_32。然后把以前旧的元素的最小编码进行提升，也就是通通改成INTSET_ENC_INT32的编码方式，用4个字节进行存储。所以接下来就是调整数据空间的大小，因为当前intset中已经有2个元素了，占用了4个字节，最小编码提升后，由于每一个元素要占用4个字节，所以旧元素总共要新增4个字节，在加上新插入的元素总共要增加8个字节的空间。<br><img src="/images/INTSET_ENC_INT32.png" alt="INTSET_ENC_INT32"><br>由于新插入的元素要么比当前intset中的元素都要大，要么都要小(因为当前intset中的元素以前都是INTSET_ENC_16编码的，也就是2个字节的整数，所以当前插入的元素是4个字节整数的，要么比当前intset中的元素都大，要么都要小(负数))，所以要么是插入到头部，要么是插入到尾部，假设插入的元素比当前intset中的元素都要小，所以插入到头部。<br><img src="/images/INTSET_ENC_INT32_1.png" alt="INTSET_ENC_INT32"><br>如果后续插入编码方式为INTSET_ENC_INT16的整数，那么由于当前encoding为INTSET_ENC_INT32，所以要按照encoidng的方式插入整数。如果后续插入的是INTSET_ENC_INT64的整数，则按照前面的方法一样。<br>至于从intset中删除元素，则很简单了，按照当前encoding的方式删除元素即可。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/10/11/ziplist/" itemprop="url">
                Redis ziplist实现
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-10-11T20:01:10+08:00" content="2015-10-11">
            2015-10-11
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/redis/" itemprop="url" rel="index">
                  <span itemprop="name">redis</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/10/11/ziplist/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/11/ziplist/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>ziplist结构是Redis内部用来实现REDIS_ENCODING_ZIPLIST对象编码的。</p>
<h3 id="ziplist结构分析"><a href="#ziplist结构分析" class="headerlink" title="ziplist结构分析"></a>ziplist结构分析</h3><p>首先我们从总体上来看下ziplist结构的总体布局:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;zlbytes&gt;&lt;zltail&gt;&lt;zllen&gt;&lt;entry&gt;&lt;entry&gt;...&lt;entry&gt;&lt;zlend&gt;</span><br></pre></td></tr></table></figure></p>
<p>接着看看ziplist中每一个部分的作用.</p>
<h3 id="ziplist的头部"><a href="#ziplist的头部" class="headerlink" title="ziplist的头部"></a>ziplist的头部</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;zlbytes&gt;&lt;zltail&gt;&lt;zllen&gt;</span><br></pre></td></tr></table></figure>
<p>一起组成了ziplist的头部部分。这三部分描述了一个ziplist结构的总体信息:</p>
<ol>
<li><code>&lt;zlbytes&gt;</code>是一个unsigned integer，表示ziplist所占用的字节数大小。</li>
<li><code>&lt;zltail&gt;</code>表示到最后一个entry的字节偏移量。有了这个字段我们就能很快定位到最后一个entry</li>
<li><code>&lt;zllen&gt;</code>代表了当前ziplist中有多少个entry。</li>
</ol>
<hr>
<h3 id="lt-entry-gt-部分"><a href="#lt-entry-gt-部分" class="headerlink" title="&lt;entry&gt;部分"></a><code>&lt;entry&gt;</code>部分</h3><p>一个<code>&lt;entry&gt;</code>就代表了ziplist中的一个元素。如果一个ziplist中没有一个元素，说明此时ziplist是一个空的，不存在任何数据。大于等于0个<code>&lt;entry&gt;</code>构成了ziplist的主体部分。下面来看看<code>&lt;entry&gt;</code>结构是个什么样子。<br>特别注意的是<code>&lt;entry&gt;</code>的大小不是固定不变的，不同的<code>&lt;entry&gt;</code>它的大小有可能是不一样的。下面是<code>&lt;entry&gt;</code>的结构:<br><img src="/images/ZiplistEntry.png" alt="entry结构"><br>首先<code>&lt;entry&gt;</code>的header中的第一部分表示前一个<entry>的大小。这一部分的长度不是固定的，根据前一个<code>&lt;entry&gt;</code>的大小的不同而不同:</entry></p>
<ol>
<li>如果前一个<code>&lt;entry&gt;</code>的大小小于254字节，那么这一部分就占用一个字节的大小来表示前一个<code>&lt;entry&gt;</code>的大小</li>
<li>如果前一个<code>&lt;entry&gt;</code>的大小大于或者等于254个字节，那么这一部分就占用5个字节来表示前一个<code>&lt;entry&gt;</code>的大小。其中第一个字节被设置成254，用来表明接下来要用4个字节来表达前一个<code>&lt;entry&gt;</code>的大小。</li>
</ol>
<hr>
<p>在来看看<code>&lt;entry&gt;</code> header的第二部分。这一部分是<code>&lt;entry&gt;</code>的类型和大小编码。用来描述这个<code>&lt;entry&gt;</code>数据部分存储的是一串字符串还是一个整数，并描述了<code>&lt;entry&gt;</code>数据部分用来存储这些数据所占用的字节数大小。</p>
<h5 id="当数据部分是一串字符串的时候"><a href="#当数据部分是一串字符串的时候" class="headerlink" title="当数据部分是一串字符串的时候"></a>当数据部分是一串字符串的时候</h5><ol>
<li>|00pppppp| - 当数据部分是一串字符串且大小小于或等于63个字节的时候，该部分占用1一个字节。前2个比特位设置成00，后面的6个比特位用来描述数据部分的大小</li>
<li>|01pppppp|qqqqqqqq| - 当数据部分是一串字符串且大小小于或者等于16383字节(14个比特位表示)的时候，该部分占用2个字节的大小，前2个比特位被设置成01，后面的14个比特位描述数据部分的大小。</li>
<li>|10<strong>__</strong>|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt| - 当数据部分是一串字符串的时候并且大小大于或者等于16384字节的时候，该部分占用5个字节大小，前2个比特位被设置成10，后4个字节用来描述数据部分的大小。<h5 id="当数据部分是整数的时候"><a href="#当数据部分是整数的时候" class="headerlink" title="当数据部分是整数的时候"></a>当数据部分是整数的时候</h5>当数据部分是一个整数的时候，该部分只占用了1个字节的大小。其中前2个比特位被设置成11，表示<code>&lt;entry&gt;</code>的数据部分是一个整数。后6个比特位用来表示该整数占用的字节数。</li>
<li>|11000000| - 表明数据部分占用了2个字节，存储的是一个int16_t类型的整数</li>
<li>|11010000| - 表明数据部分占用了4个字节，存储的是一个int32_t类型的整数</li>
<li>|11100000| - 表明数据部分占用了8个字节，存储的是一个int64_t类型的整数</li>
<li>|11110000| - 表明数据部分占用了3个字节，存储的是一个24比特位的整数</li>
<li>|11111110| - 表明数据部分占用了1个字节，存储的是8比特位的整数</li>
<li>|1111xxxx| - 此时该<code>&lt;entry&gt;</code>无数据部分。当存储的整数是0~12的时候，直接用该部分的后4个比特位来表示。因为后4个比特位不能为0000和1110和1111，所以xxxx能够表示的范围为0001~1101，也就是能够表示的整数位1~13，但是我们要表示的是整数范围是0~12，所以为了取得正确的值，记得要进行减一操作。</li>
</ol>
<hr>
<h3 id="lt-zlend-gt"><a href="#lt-zlend-gt" class="headerlink" title="&lt;zlend&gt;"></a><code>&lt;zlend&gt;</code></h3><h2 id="lt-zlend-gt-是ziplist的尾部，它占用一个字节，被固定设置成255，用来表示该位置是ziplist的结束部分了。"><a href="#lt-zlend-gt-是ziplist的尾部，它占用一个字节，被固定设置成255，用来表示该位置是ziplist的结束部分了。" class="headerlink" title="&lt;zlend&gt;是ziplist的尾部，它占用一个字节，被固定设置成255，用来表示该位置是ziplist的结束部分了。"></a><code>&lt;zlend&gt;</code>是ziplist的尾部，它占用一个字节，被固定设置成255，用来表示该位置是ziplist的结束部分了。</h2><h3 id="Redis-list类型"><a href="#Redis-list类型" class="headerlink" title="Redis list类型"></a>Redis list类型</h3><p>接下来我们看看Redis list类型的数据怎么用ziplist来实现REDIS_ENCODING_ZIPLIST对象编码的。<br>假如一个list对象由三个元素组成:valxxx…xxx56,valxxx…xxx256,10,65530。第一个元素是大小为56个字节的字符串，第二个元素是大小为256的字符串，第三个和第四个元素都是整数。我们看看怎么用REDIS_ENCODING_ZIPLIST对象编码来存储的。<br><img src="/images/REDIS_ENCODING_ZIPLIST.png" alt="REDIS_ENCODING_ZIPLIST"><br>再来看看一个完整的使用了REDIS_ENCODING_ZIPLIST对象编码的Redis list对象的结构:<br><img src="/images/redis_list_1.png" alt="REDIS_LIST"></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/">&laquo;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">&raquo;</a>
  </nav>

 </div>

        

        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/xiaohuangren.png" alt="龙雄球" itemprop="image"/>
          <p class="site-author-name" itemprop="name">龙雄球</p>
        </div>
        <p class="site-description motion-element" itemprop="description">丑霸一枚</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">23</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">4</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">龙雄球</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"iovcc"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     

    
  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
